/*******************************************************************************
* wallaroo - A library for configurable creation and wiring of C++ classes.
* Copyright (C) 2012 Daniele Pallastrelli
*
* This file is part of wallaroo.
* For more information, see http://wallaroolib.sourceforge.net/
*
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
******************************************************************************/

#include <boost/test/unit_test.hpp>

#include "wallaroo/detail/tokensource.h"

using namespace wallaroo;
using namespace wallaroo::detail;

BOOST_AUTO_TEST_SUITE(TokenSourceSuite)

BOOST_AUTO_TEST_CASE(Empty)
{
    std::stringstream s;
    TokenSource ts( s );
    Token token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::done);
}

BOOST_AUTO_TEST_CASE(Spaces)
{
    std::stringstream s;
    s << " \t   \n  ";
    TokenSource ts(s);
    Token token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::done);
}

BOOST_AUTO_TEST_CASE(Comments)
{
    std::stringstream s;
    s << " \t   \n"
      << "   #    new \n"
      << "#load";
    TokenSource ts(s);
    Token token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::done);
}

BOOST_AUTO_TEST_CASE(TokensType)
{
    std::stringstream s;
    s << " \t  @load \n"
        << "     new(); \n"
        << ", = . foo 42";
    TokenSource ts(s);
    Token token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::load);
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::create);
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::open);
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::close);
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::stmtsep);
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::attrsep);
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::assign);
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::collsep);
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::id);
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::value);
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::done);
}


BOOST_AUTO_TEST_CASE(Identifiers)
{
    std::stringstream s;
    s << "_ _123 _abc _ABC abc123 a<b> Foo::Bar";
    TokenSource ts(s);
    Token token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::id);
    BOOST_CHECK_EQUAL(token.lexem, "_");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::id);
    BOOST_CHECK_EQUAL(token.lexem, "_123");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::id);
    BOOST_CHECK_EQUAL(token.lexem, "_abc");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::id);
    BOOST_CHECK_EQUAL(token.lexem, "_ABC");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::id);
    BOOST_CHECK_EQUAL(token.lexem, "abc123");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::id);
    BOOST_CHECK_EQUAL(token.lexem, "a<b>");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::id);
    BOOST_CHECK_EQUAL(token.lexem, "Foo::Bar");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::done);
}


BOOST_AUTO_TEST_CASE(Values)
{
    std::stringstream s;
    s << "true false 'a' ' ' \"\" \"123 abc \" 0 -10 +123.0 -0.123";
    TokenSource ts(s);
    Token token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::value);
    BOOST_CHECK_EQUAL(token.lexem, "true");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::value);
    BOOST_CHECK_EQUAL(token.lexem, "false");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::value);
    BOOST_CHECK_EQUAL(token.lexem, "a");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::value);
    BOOST_CHECK_EQUAL(token.lexem, " ");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::value);
    BOOST_CHECK_EQUAL(token.lexem, "");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::value);
    BOOST_CHECK_EQUAL(token.lexem, "123 abc ");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::value);
    BOOST_CHECK_EQUAL(token.lexem, "0");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::value);
    BOOST_CHECK_EQUAL(token.lexem, "-10");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::value);
    BOOST_CHECK_EQUAL(token.lexem, "+123.0");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::value);
    BOOST_CHECK_EQUAL(token.lexem, "-0.123");
    token = ts.Next();
    BOOST_CHECK_EQUAL(token.type, Token::done);
}

BOOST_AUTO_TEST_CASE(Ko)
{
    std::stringstream s;
    s << "%";
    TokenSource ts(s);
    BOOST_CHECK_THROW({ ts.Next(); }, LexicalError);
}

BOOST_AUTO_TEST_SUITE_END()