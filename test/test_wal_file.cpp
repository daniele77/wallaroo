/*******************************************************************************
 * wallaroo - A library for configurable creation and wiring of C++ classes.
 * Copyright (C) 2012 Daniele Pallastrelli
 *
 * This file is part of wallaroo.
 * For more information, see http://wallaroolib.sourceforge.net/
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

#include <boost/test/unit_test.hpp>
#include "plugin_interface.h"

#include "wallaroo/registered.h"
#include "wallaroo/catalog.h"
#include "wallaroo/configuration.h"
#include "wallaroo/cxx0x.h"

using namespace wallaroo;
using namespace cxx0x;


// a base class to automate the definition of the test class

namespace
{

class Base : public Part
{
public:
    Base() {}
};

};


#define DEFINE_2ATT_CLASS( name, p1, p2 ) \
    class name : public Base \
    { \
    public: \
        name() : \
            Base(), \
            att1( "att1", RegistrationToken() ), \
            att2( "att2", RegistrationToken() ) \
            {} \
        Attribute< p1 > att1; \
        Attribute< p2 > att2; \
    }; \
    WALLAROO_REGISTER( name )

// some classes:

class I8 : public Part
{
public:
    virtual int F() = 0;
    virtual ~I8() {}
};

class A8 : public I8
{
public:
    virtual int F() { return 5; }
    virtual ~A8() {}
};

WALLAROO_REGISTER( A8 )

class B8 : public A8
{
public:
    B8() : att_int( "att_int", RegistrationToken() ) {}
    virtual int F() { return att_int; }
    virtual ~B8() {}
private:
    Attribute< int > att_int;
};

WALLAROO_REGISTER( B8 )

class C8 : public Part
{
public:
    C8() : x( "x", RegistrationToken() ), att_ui( "att_ui", RegistrationToken() ) {}
    virtual int F() { return x -> F(); }
    virtual ~C8() {}
private:
    Collaborator< I8 > x;
    Attribute< unsigned int > att_ui;
};

WALLAROO_REGISTER( C8 )

namespace Foo
{
    class D8 : public Part
    {
    public:
        D8() :
            container( "container", RegistrationToken() ),
            s( "att_string", RegistrationToken() ),
            ii( "att_int", RegistrationToken() )
        {
        }
        std::string String() const { return s; }
        int Int() const { return ii; }
        int F() const
        {
            int sum = 0;
            for ( Container::const_iterator i = container.begin(); i != container.end(); ++i )
            {
                sum += i->lock()->F();
            }
            return sum;
        }
    private:
        typedef Collaborator< I8, collection<> > Container;
        Container container;
        Attribute< std::string > s;
        Attribute< int > ii;
    };
}

WALLAROO_REGISTER( Foo::D8 )


DEFINE_2ATT_CLASS( E8, unsigned int, double )
DEFINE_2ATT_CLASS( F8, double, bool )
DEFINE_2ATT_CLASS( G8, bool, bool )
DEFINE_2ATT_CLASS( H8, double, double )
DEFINE_2ATT_CLASS( L8, int, std::string )
DEFINE_2ATT_CLASS( M8, long, char )
DEFINE_2ATT_CLASS( N8, char, unsigned char )

template < typename T >
class O8 : public Part
{
public:
    O8() : x( 10 ) {}
    int F() { return x;  }
    virtual ~O8() {}
private:
    const int x;
};

WALLAROO_REGISTER( O8<double> )
WALLAROO_REGISTER( O8<int> )

// tests

BOOST_AUTO_TEST_SUITE( WalFile )

BOOST_AUTO_TEST_CASE( WalNotFound )
{
    BOOST_CHECK_THROW( Configuration( "UnexistentFile.wal" ), WrongFile );
}

static void TestContent( Catalog& catalog )
{
    BOOST_REQUIRE( catalog.IsWiringOk() );

    shared_ptr< C8 > c1 = catalog[ "c1" ];
    BOOST_CHECK( c1 -> F() == 5 );

    shared_ptr< C8 > c2 = catalog[ "c2" ];
    BOOST_CHECK( c2 -> F() == 10 );

    shared_ptr< Foo::D8 > d = catalog[ "d" ];
    BOOST_CHECK( d -> String() == "mystring" );
    BOOST_CHECK( d -> Int() == 34 );
    BOOST_CHECK( d -> F() == 15 );

    shared_ptr< E8 > e = catalog[ "e" ];
    BOOST_CHECK( e -> att1 == 5 );
    BOOST_CHECK( e -> att2 == 3.14 );

    shared_ptr< F8 > f = catalog[ "f" ];
    BOOST_CHECK( f -> att1 == 3.14 );
    BOOST_CHECK( f -> att2 == false );

    shared_ptr< G8 > g = catalog[ "g" ];
    BOOST_CHECK( g -> att1 == false );
    BOOST_CHECK( g -> att2 == true );

    shared_ptr< H8 > h = catalog[ "h" ];
    BOOST_CHECK( h -> att1 == 1.0 );
    BOOST_CHECK( h -> att2 == -2.0 );

    shared_ptr< L8 > l = catalog[ "l" ];
    BOOST_CHECK( l -> att1 == -100 );
    BOOST_CHECK( l -> att2 == std::string("foo bar") );

    shared_ptr< M8 > m = catalog[ "m" ];
    BOOST_CHECK( m -> att1 == -2000000000L );
    BOOST_CHECK( m -> att2 == 'a' );

    shared_ptr< N8 > n = catalog[ "n" ];
    BOOST_CHECK( n -> att1 == 'b' );
    BOOST_CHECK( n -> att2 == 200 );

    shared_ptr< I6 > p = catalog[ "p" ];
    BOOST_CHECK( p -> F() == 7 );

    shared_ptr< I6 > q = catalog[ "q" ];
    BOOST_CHECK( q -> F() == 8 );

    shared_ptr< O8< double > > o_double = catalog[ "o_double" ];
    BOOST_CHECK( o_double -> F() == 10 );

    shared_ptr< O8< int > > o_int = catalog[ "o_int" ];
    BOOST_CHECK( o_int->F() == 10 );

}

BOOST_AUTO_TEST_CASE( WalOk )
{
    Configuration file( "test_wal.wal" );
    BOOST_REQUIRE_NO_THROW( file.LoadPlugins() );
    Catalog catalog;
    BOOST_REQUIRE_NO_THROW( file.Fill( catalog ) );
    TestContent( catalog );
}

BOOST_AUTO_TEST_SUITE_END()