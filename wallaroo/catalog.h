/*******************************************************************************
 * wallaroo - A library for configurable creation and wiring of C++ classes.
 * Copyright (C) 2012 Daniele Pallastrelli
 *
 * This file is part of wallaroo.
 * For more information, see http://wallaroolib.sourceforge.net/
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

#ifndef WALLAROO_CATALOG_H_
#define WALLAROO_CATALOG_H_

#include <string>
#include <typeinfo>
#include <cassert>
#include "detail/partshell.h"
#include "cxx0x.h"
#include "part.h"
#include "class.h"

namespace wallaroo
{

// forward declarations:
class Context;
class UseAsExpression;
class UseExpression;

/**
 * Catalog of parts available for the application.
 *
 * It can create the instances from the name of a class 
 * previously registered with one of the macros
 * WALLAROO_REGISTER(C), WALLAROO_DYNLIB_REGISTER(C).
 *
 * Alternatively, you can add an instance, provided that
 * its class derives from wallaroo::Part.
 *
 * Each item in the catalog is identified by a @c id, with which
 * you can perform a lookup.
 */
class Catalog
{
public:

    /** Build an empty catalog.
    */
    Catalog() {}

    /** Look for the element @c id in the catalog. It returns a class that
    * provides conversion operator so that you can write eg:
    * \code{.cpp}
    *     shared_ptr< Foo > foo = catalog[ "foo" ];
    * \endcode
    * @param id The name of the element
    * @return The element.
    * @throw ElementNotFound If an element with key @c id cannot be found
    *                        in the catalog.
    */
    detail::PartShell operator [] ( const std::string& id ) const
    {
        Parts::const_iterator i = parts.find( id );
        if ( i == parts.end() ) throw ElementNotFound( id );
        return detail::PartShell( i -> second );
    }

    /** Add an element to the catalog
    * @param id The name of the element to add
    * @param dev The element to add (its class must derive from wallaroo::Part)
    * @throw DuplicatedElement If a part with the name @c id is already in the catalog
    */
    void Add( const std::string& id, const cxx0x::shared_ptr< Part >& dev )
    {
        std::pair< Parts::iterator, bool > result = 
            parts.insert( std::make_pair( id, dev ) );
        if ( ! result.second ) throw DuplicatedElement( id );
    }

    /** Remove an element from the catalog
    * @param id The name of the element to remove
    * @throw ElementNotFound If an element with key @c id cannot be found
    *                        in the catalog.
    */
    void Remove( const std::string& id )
    {
        if ( parts.erase( id ) != 1 ) throw ElementNotFound( id );
    }

    /** Remove all elements of the catalog */
    void Clear() { parts.clear(); }

    /** Returns the number of the elements contained in the catalog.
    * @return the size of the container
    */
    std::size_t Size() const { return parts.size();  }

    /** Instantiate a class having a 2 parameters constructor and add it to the catalog
    * @param id The name of the element to create and add
    * @param className The name of the class to instantiate (must derive from wallaroo::Part)
    * @param p1 The first parameter of the class constructor
    * @param p2 The second parameter of the class constructor
    * @return The element created.
    * @throw DuplicatedElement If an element with the name @c id is already in the catalog
    * @throw ElementNotFound If @c className class has not been registered
    */
    template < class P1, class P2 >
    detail::PartShell Create( const std::string& id, const std::string& className, const P1& p1, const P2& p2 )
    {
        typedef Class< P1, P2 > C;
        C c = C::ForName( className );
        cxx0x::shared_ptr< Part > obj = c.NewInstance( p1, p2 );
        if ( obj.get() == NULL ) throw ElementNotFound( className );
        Add( id, obj );
        return detail::PartShell( obj );
    }

    /** Instantiate a class having a 1 parameters constructor and add it to the catalog
    * @param id The name of the element to create and add
    * @param className The name of the class to instantiate (must derive from wallaroo::Part)
    * @param p The parameter of the class constructor
    * @return The element created.
    * @throw DuplicatedElement If an element with the name @c id is already in the catalog
    * @throw ElementNotFound If @c className class has not been registered
    */
    template < class P >
    detail::PartShell Create( const std::string& id, const std::string& className, const P& p )
    {
        typedef Class< P, void > C;
        C c = C::ForName( className );
        cxx0x::shared_ptr< Part > obj = c.NewInstance( p );
        if ( obj.get() == NULL ) throw ElementNotFound( className );
        Add( id, obj );
        return detail::PartShell( obj );
    }

    /** Instantiate a class having a default constructor and add it to the catalog
    * @param id The name of the element to create and add
    * @param className The name of the class to instantiate (must derive from wallaroo::Part)
    * @return The element created.
    * @throw DuplicatedElement If an element with the name @c id is already in the catalog
    * @throw ElementNotFound If @c className class has not been registered
    */
    detail::PartShell Create( const std::string& id, const std::string& className )
    {
        typedef Class< void, void > C;
        C c = C::ForName( className );
        cxx0x::shared_ptr< Part > obj = c.NewInstance();
        if ( obj.get() == NULL ) throw ElementNotFound( className );
        Add( id, obj );
        return detail::PartShell( obj );
    }

    /** Check if the wiring of the objects inside the container
    * is correct according to the multiplicity declared in the Collaborator definition.
    * @return false If the wiring does not match with the multiplicity declared.
    */
    bool IsWiringOk() const
    {
        return FindWrongMultiplicity().empty();
    }

    /** Check if the wiring of the objects inside the container
    * is correct according to the multiplicity declared in the Collaborator definition.
    * @throw WiringError If the wiring does not match with the multiplicity declared.
    */
    void CheckWiring() const
    {
        const std::string wrongPart = FindWrongMultiplicity();
        if ( !wrongPart.empty() ) throw WiringError( wrongPart );
    }

    /** This method calls Part::Init on every Part contained.
     *  You can call it in the setup phase of your application to perform
     *  the initialization required by each part before the run.
     *  Ideally you should call it *after* wiring and attributes setting, so that
     *  your objects already have dependencies and the right attribute values.
     *  This method rethrows every exception thrown by each Part::Init.
     */
    void Init()
    {
        for ( Parts::const_iterator i = parts.begin(); i != parts.end(); ++i )
            i -> second -> Init();
    }

private:

    // copy ctor and assignment operator disabled
    Catalog( const Catalog& );
    Catalog& operator = ( const Catalog& );

    // returns the name of the first parts with wrong multiplicity
    // or the empty string if the test has success
    std::string FindWrongMultiplicity() const
    {
        for( Parts::const_iterator i = parts.begin(); i != parts.end(); ++i )
        {
            if ( ! i -> second -> MultiplicitiesOk() )
                return( i -> first );
        }
        return std::string();
    }

    typedef cxx0x::unordered_map< std::string, cxx0x::shared_ptr< Part > > Parts;
    Parts parts;

    friend class Context;
    friend class UseAsExpression;
    friend class SetExpression;
    friend UseExpression use( const std::string& destClass );
    friend bool IsWiringOk();
    friend void CheckWiring();


    static Catalog*& Current()
    {
        static Catalog* current = NULL;
        return current;
    }
};


// This is a helper class that provides the result of the use().as() function
// useful to concatenate use().as() with of().
class UseAsExpression
{
public:
    UseAsExpression( detail::PartShell& _destClass, const std::string& _attribute ) :
      destClass( _destClass ),
      attribute( _attribute )
    {
    }
    // throw ElementNotFound If @c attribute does not exist in @c srcClass.
    // throw WrongType If @c destClass has not a type compatible with the dependency.
    void of( const detail::PartShell& srcClass )
    {
        // perform the final assignment:
        srcClass.Wire( attribute, destClass );
    }
    // throw CatalogNotSpecified if the current catalog has not been selected with wallaroo_within
    // throw ElementNotFound If @c attribute does not exist in this part or 
	//       if @c srcClass key is not found in the current catalog.
    // throw WrongType If @c destClass has not a type compatible with the dependency.
    void of( const std::string& srcClass )
    {
        // default container case
        Catalog* current = Catalog::Current();
        if ( ! current ) throw CatalogNotSpecified();
        of( ( *current )[ srcClass ] );
    }
private:
    const detail::PartShell destClass;
    const std::string attribute;
};

// This is a helper class that provides the result of the use() function
// useful to concatenate use() with as().
class UseExpression
{
public:
    explicit UseExpression( const detail::PartShell& _destClass )
        : destClass( _destClass )
    {
    }
    UseAsExpression as( const std::string& attribute )
    {
        return UseAsExpression( destClass, attribute );
    }
private:
    detail::PartShell destClass;
};


/**
 * This function provides the "use" part in the syntax 
 * @c use( catalog[ "part1" ] ).as( "collaborator" ).of( catalog[ "part2" ] )
 */
inline UseExpression use( const detail::PartShell& destClass )
{
    return UseExpression( destClass );
}

/**
 * This function provides the "use" part in the syntax @c use( "part1" ).as( "collaborator" ).of( "part2" )
 * @throw CatalogNotSpecified if the current catalog has not been selected including
 * this function in a wallaroo_within section
 */
inline UseExpression use( const std::string& destClass )
{
    // default container case
    Catalog* current = Catalog::Current();
    if ( ! current ) throw CatalogNotSpecified();
    return use( ( *current )[ destClass ] );
}


// This is a helper class that provides the result of the set_attribute().of() function
// useful to concatenate set_attribute().of() with to().
class SetOfExpression
{
public:
    SetOfExpression( const detail::PartShell& _part, const std::string& _attribute ) :
        part( _part ), attribute( _attribute ) {}
    // throw ElementNotFound If attribute does not exist in this part.
    // throw WrongType If @c value has not a type compatible with the attribute.
    template < typename T >
    void to( const T& value )
    {
        // perform the final assignment:
        part.SetAttribute( attribute, value );
    }
private:
    const detail::PartShell part;
    const std::string attribute;
};

// This is a helper class that provides the result of the set_attribute() function
// useful to concatenate set_attribute() with of().
class SetExpression
{
public:
    explicit SetExpression( const std::string& att ) : attribute( att ) {}
    SetOfExpression of( const detail::PartShell& part ) { return SetOfExpression( part, attribute ); }
    // throw CatalogNotSpecified if the current catalog has not been selected including
    // this function in a wallaroo_within section
    SetOfExpression of( const std::string& part )
    {
        // default container case
        Catalog* current = Catalog::Current( );
        if ( !current ) throw CatalogNotSpecified( );
        return SetOfExpression( ( *current )[ part ], attribute );
    }
private:
    const std::string attribute;
};

/**
* This function provides the "set_attribute" part in the syntax @c set_attribute( "attribute" ).of( "part" ).to( value )
* @throw CatalogNotSpecified if the current catalog has not been selected including
* this function in a wallaroo_within section
*/
inline SetExpression set_attribute( const std::string& attribute ) { return SetExpression( attribute ); }


// Helper class that changes the current catalog on the ctor and
// restores the previous on the dtor
class Context
{
public:
    Context( Catalog& c ) :
      firstTime( true )
    {
        previous = Catalog::Current();
        Catalog::Current() = &c;
    }
    ~Context()
    {
        Catalog::Current() = previous;
    }
    bool FirstTime() const
    {
        return firstTime;
    }
    void Terminate()
    {
        firstTime = false;
    }
private:
    bool firstTime;
    Catalog* previous;
};


/**
 * This preamble creates a scope in which every statement @c use().as().of() will use
 * the catalog @c C withouth the need to specify it every time.
 * So, this code:
 * @code{.cpp}
 * Catalog myCatalog;
 * ...
 * wallaroo_within( myCatalog )
 * {
 *     use( "f136e" ).as( "engine" ).of( "ferrari_f430" );
 *     use( "m139p" ).as( "engine" ).of( "maserati_granturismo" );
 * }
 * @endcode
 * is equivalent to:
 * @code{.cpp}
 * Catalog myCatalog;
 * ...
 * use( myCatalog[ "f136e" ] ).as( "engine" ).of( myCatalog[ "ferrari_f430" ] );
 * use( myCatalog[ "m139p" ] ).as( "engine" ).of( myCatalog[ "maserati_granturismo" ] );
 * @endcode
 *
 * @hideinitializer
 */
#define wallaroo_within( C ) \
    for ( wallaroo::Context context( C ); context.FirstTime(); context.Terminate() )

////////////////////////////////////////////////////////////////////////

} // namespace

#endif
